<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApplyMappingException" xml:space="preserve">
    <value>Exception has happened on attempt to apply mapping. See the Inner Exception for more details</value>
    <comment>Exception describes some general exception on attempt to apply Select statement to IQueryable</comment>
  </data>
  <data name="ArgumentsAreRequiredException" xml:space="preserve">
    <value>Arguments can't be null for this overload of AsQuery method</value>
    <comment>Exception will happen if args are null for one of overloads of AsQuery method where args are required</comment>
  </data>
  <data name="ContextKeyIsRequredException" xml:space="preserve">
    <value>Context Key was null. In Current version Context Key is required parameter.</value>
    <comment>Exception will be thrown if used AsQuery method with context key argument and context key will be passed as null</comment>
  </data>
  <data name="ContextResolverIsntRegisteredException" xml:space="preserve">
    <value>Context Resolver wasn't registered for type {0}. To use Query Mappings you need to register context resolver function.</value>
    <comment>Exception will be thrown if context resolver function isn't registered</comment>
  </data>
  <data name="GeneralInitializationException" xml:space="preserve">
    <value>Exception has happened during mappings initialization. Please see Inner Exception to find more details.</value>
    <comment>General exception message if any error has happened in MappingConfiguration class</comment>
  </data>
  <data name="GeneralMappingStorageException" xml:space="preserve">
    <value>General exception has happened on attempt to create IMappingStorage instance of type {0}</value>
    <comment>Any other exception when Activator.CreateInstance tried to create instance of IMappingStorage</comment>
  </data>
  <data name="InvalidCastMappingException" xml:space="preserve">
    <value>Mapping from type {0} to type {1} was found, but you are using incorrect version of AsQuery method for this type of mapping. You are using AsQuery method that is used {4} arguments and {5} EF context, but founded mapping was registered {2} arguments and {3} EF context</value>
    <comment>AsQuery method has 4 different overloads: mapping without paramteres, mapping with parameters, mapping with EF context available in it and mapping with both parameters and EF context. This exception will happen when incorrect version is used</comment>
  </data>
  <data name="MappingNotFoundException" xml:space="preserve">
    <value>Mapping from {0} to {1} was not found</value>
    <comment>Mapping for this 2 types wasn't found</comment>
  </data>
  <data name="MappingStorageSetupException" xml:space="preserve">
    <value>Exception has happened inside of Setup method invokation on IMappingStorage of type {0}</value>
    <comment>Exception will happen if any error happens in Setup method of IMappingStorage implementation</comment>
  </data>
  <data name="MoreThanOneMappingFoundException" xml:space="preserve">
    <value>More than one mapping from {0} to {1} was found. If you have more than one mapping for the same model you can use Named Mappings (see documentation) or create different models for different mappings</value>
    <comment>Exception will happen if you have more than one mapping from type A to type B and more than one of them without explicitl name (so we don't know exactly which mapping we need)</comment>
  </data>
  <data name="NameIsNullWhenSearchForNamedMappingException" xml:space="preserve">
    <value>A few mappings from {0} to {1} were found, but 'name' argument wasn't passed into method. Can't choose correct one. Please pass 'name' argument explicitly</value>
    <comment>Exception will happen if mapping was found, but mapping was registered with explicit name and you didn't pass any name into resolver</comment>
  </data>
  <data name="NoEmptyConstructorInitializationException" xml:space="preserve">
    <value>Couldn't find empty constructor for IMappingStorage implementation: {0}</value>
    <comment>Exception will happen if any of IMappingStorage implementations has non-default constructor and doesn't implement empty constructor</comment>
  </data>
</root>